}
for(n in c(10000,25000,50000))
for(ww in c(100,1000,5000))
plotmarkov(n = n, window = ww, title = paste0(n," simulations with window width = ",ww))
x.Date <- as.Date(paste(2004, rep(1:4, 4:1), sample(1:28, 10), sep = "-"))
x <- zoo(rnorm(12), x.Date)
x <- rnorm(100)
rollmean(x, 3)
library(roll)
library('roll')
version
library(zoo)
library(zoo)
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1  ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(n=10000, start=0, window=100, transition=P, npanels=5)
library("lattice")
library("zoo")
library("lattice")
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1  ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(n=10000, start=0, window=100, transition=P, npanels=5)
library("zoo")
library("lattice")
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1  ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
for(sim in c(10000, 50000, 100000)){
for(win in c(100,500,1000)){
plotmarkov(n=sim, start=0, window=win, transition=P, npanels=5)
}
}
M <- 6 # number of friends
K <- 4 # zones
n <- 50 # number of shots
great_player <- sample( 1:K, n, replace=TRUE, prob =c( 2/16, 4/16, 5/16, 5/16))
observed <- table(great_player)
chisq.test( observed, p = c( 7/16, 5/16, 3/16, 1/16))
obs <- matrix(data = 0, nrow = M, ncol = K)
for(i in 1:M){
obs[i,] <- table(sample( 1:K, n, replace=TRUE, prob =c( 7/16, 5/16, 3/16, 1/16))) # almost same guys
}
Markov <- function (N=100, initial.value=1, P)
{
X <- numeric(N)
X[1] <- initial.value + 1 # States 0:5; subscripts 1:6
n <- nrow(P)
for (i in 2:N){
X[i] <- sample(1:n, size=1, prob=P[X[i-1], ])}
X - 1
}
P <- matrix(c(c(0.6,0.2,0.2),c(0.2,0.4,0.4),c(0.4,0.3,0.3)),byrow = TRUE, nrow = 3)
result <- Markov(100000,1,P)
table(result)/length(result)
library("zoo")
library("lattice")
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1  ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
# could not interpret this part, better code will be written
for(sim in c(50000, 100000)){
for(win in c(100,500,1000)){
plotmarkov(n=sim, start=0, window=win, transition=P, npanels=5)
}
}
library("zoo")
library("lattice")
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1  ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
# could not interpret this part, better code will be written
for(sim in c(50000, 100000)){
for(win in c(100,1000)){
plotmarkov(n=sim, start=0, window=win, transition=P, npanels=5)
}
}
par (mfrow=c(1,2), oma=c(0,0,0,0))
y1 <- rnorm(51)
y1 # this is iid
y <- y1[-1] + y1[-51]
y # this is not iid
acf(y1) # acf is `autocorrelation function' (see Ch. 9)
acf(y)
library(knitr)
local({
hook_plot = knit_hooks$get('plot')
knit_hooks$set(plot = function(x, options) {
paste0('\n\n----\n\n', hook_plot(x, options))
})
})
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 1000, init = 0, Mat= Pb))
results
print(results/1000)
#0:Sun, 1:Cloud, 2:rain
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 100000000, init = 0, Mat= Pb))
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 1000000, init = 0, Mat= Pb))
results
print(results/1000)
#0:Sun, 1:Cloud, 2:rain
library(zoo)
library(lattice)
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1 ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(window = 10)
plotmarkov(window = 100)
plotmarkov(window = 1000)
plotmarkov(n=1000, window = 10)
plotmarkov(n=1000, window = 100)
Markov <- function (N=100, initial.value=1, P){
X <- numeric(N)
X[1] <- initial.value + 1  # States 0:5; subscripts 1:6
n <- nrow(P)
for (i in 2:N){
X[i] <- sample(1:n, size=1, prob=P[X[i-1], ])
}
X-1
}
Pb <- matrix(nrow = 3, ncol = 3, byrow = TRUE, data = c(.6,.2,.2,.2,.4,.4,.4,.3,.3),
dimnames = list(c("Sun", "Cloud", "Rain"), c("Sun", "Cloud", "Rain")))
chain <- factor(Markov(1000000, 0, Pb), labels = c("Sun", "Cloud", "Rain"))
table(chain)/length(chain)
library(zoo)
library(lattice)
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1 ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(window = 10)
plotmarkov(window = 100)
plotmarkov(window = 1000)
plotmarkov(n=1000, window = 10)
plotmarkov(n=1000, window = 100)
?xyplot
library(Matrix)
A        <- matrix(nrow = 3, ncol = 3, byrow = TRUE, data = c(.6,.2,.2,.2,.4,.4,.4,.3,.3))
b        <- c(0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
a        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(a) <- c('state.1', 'state.2', 'state.3')
a
a        <- drop(solve(t(A) %*% A, t(A) %*% b))
b %*% solve(A)
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(.6,.2,.2,1,.2,.4,.4,1,.4,.3,.3,1))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
matrix()
A
A        <- matrix(c(-0.3, 0.2, 0.1, 1, 0.4, -0.4, 0, 1, 0, 1, -1, 1 ), ncol=3,nrow=4)
A
A        <- matrix(nrow = 3, ncol = 3, byrow = TRUE, data = c(.6,.2,.2,.2,.4,.4,.4,.3,.3))
A
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
A
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 1000, init = 0, Mat= Pb))
results
print(results/1000)
#0:Sun, 1:Cloud, 2:rain
library(DAAG)
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 100000, init = 0, Mat= Pb))
results
print(results/100000)
#0:Sun, 1:Cloud, 2:rain
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('state.1', 'state.2', 'state.3')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
plotmarkov(window = 10 title = "10000 with width = 10")
plotmarkov(window = 10 title = paste("10000 with width = 10"))
library(zoo)
library(lattice)
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1 ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(window = 10 title = paste("10000 with width = 10"))
plotmarkov(window = 10 ,title = paste("10000 with width = 10"))
library(zoo)
library(lattice)
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1 ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(window = 10)
plotmarkov(window = 100)
plotmarkov(window = 1000)
plotmarkov(n=1000, window = 10)
plotmarkov(n=1000, window = 100)
library(zoo)
library(lattice)
plotmarkov <- function(n=10000, start=0, window=100, transition=Pb, npanels=5){
xc2 <- Markov(n, start, transition)
mav0 <- rollmean(as.integer(xc2==0), window)
mav1 <- rollmean(as.integer(xc2==0), window)
npanel <- cut(1:length(mav0), breaks=seq(from=1, to=length(mav0),
length=npanels+1), include.lowest=TRUE)
df <- data.frame(av0=mav0, av1=mav1, x=1:length(mav0),
gp=npanel)
print(xyplot(av0+av1 ~ x | gp, data=df, layout=c(1,npanels),
type="l", par.strip.text=list(cex=0.65),
scales=list(x=list(relation="free"))))
}
plotmarkov(window = 100)
plotmarkov(window = 1000)
plotmarkov(window = 5000)
plotmarkov(n=10000, window = 1000)
plotmarkov(n=10000, window = 5000)
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 1000, init = 0, Mat= Pb))
results
print(results/1000)
#0:Sun, 1:Cloud, 2:rain
library(Matrix)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('sun', 'cloud', 'rain')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('sun', 'cloud', 'rain')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
options(digits=3)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('sun', 'cloud', 'rain')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
options(digits=3)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('sun', 'cloud', 'rain')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
options(digits=3)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('sun', 'cloud', 'rain')
pi
#ref https://stephens999.github.io/fiveMinuteStats/stationary_distribution.html
solve(A,b)
solve(a) %*% b
solve(A) %*% b
options(digits=3)
A        <- matrix(nrow = 4, ncol = 3, byrow = TRUE, data = c(c(-0.4, 0.2, 0.4, 0.2, -0.6, 0.4, 0.2, 0.4, -0.7, 1, 1, 1 )))
b        <- c(0,0,0,1)
rank.A   <- as.numeric(rankMatrix(A))
rank.Ab  <- as.numeric(rankMatrix(cbind(A,b)))
print(paste("The rank of A =", rank.A, "and the rank of the augmented matrix =", rank.Ab))
pi        <- drop(solve(t(A) %*% A, t(A) %*% b))
names(pi) <- c('sun', 'cloud', 'rain')
pi
solve(A)
solve(A,b)
A
b
pi
?solve
c(3/7, 2/7, 2/7)
set.seed(0);
Pb <- matrix(c(0.6, 0.2, 0.2,
0.2, 0.4, 0.4,
0.4, 0.3, 0.3), nrow = 3, ncol = 3, byrow = TRUE)
Markov = function(R, init, Mat ){
chain = numeric(R)
chain[1] = init+1
for(i in 2:R){
chain[i] = sample(x = 1:3, size =1, prob = Mat[chain[i-1], ])
}
chain - 1
}
results <- table(Markov(R= 1000, init = 0, Mat= Pb))
results
print(results/1000)
#0:Sun, 1:Cloud, 2:rain
